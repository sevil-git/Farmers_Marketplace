{"ast":null,"code":"/**\r\n * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.\r\n * @module Multibase\r\n */\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst constants = require('./constants');\nexports = module.exports = multibase;\nexports.encode = encode;\nexports.decode = decode;\nexports.isEncoded = isEncoded;\nexports.names = Object.freeze(Object.keys(constants.names));\nexports.codes = Object.freeze(Object.keys(constants.codes));\n\n/**\r\n * Create a new buffer with the multibase varint+code.\r\n *\r\n * @param {string|number} nameOrCode - The multibase name or code number.\r\n * @param {Buffer} buf - The data to be prefixed with multibase.\r\n * @memberof Multibase\r\n * @returns {Buffer}\r\n */\nfunction multibase(nameOrCode, buf) {\n  if (!buf) {\n    throw new Error('requires an encoded buffer');\n  }\n  const base = getBase(nameOrCode);\n  const codeBuf = Buffer.from(base.code);\n  const name = base.name;\n  validEncode(name, buf);\n  return Buffer.concat([codeBuf, buf]);\n}\n\n/**\r\n * Encode data with the specified base and add the multibase prefix.\r\n *\r\n * @param {string|number} nameOrCode - The multibase name or code number.\r\n * @param {Buffer} buf - The data to be encoded.\r\n * @returns {Buffer}\r\n * @memberof Multibase\r\n */\nfunction encode(nameOrCode, buf) {\n  const base = getBase(nameOrCode);\n  const name = base.name;\n  return multibase(name, Buffer.from(base.encode(buf)));\n}\n\n/**\r\n * Takes a buffer or string encoded with multibase header, decodes it and\r\n * returns the decoded buffer\r\n *\r\n * @param {Buffer|string} bufOrString\r\n * @returns {Buffer}\r\n * @memberof Multibase\r\n *\r\n */\nfunction decode(bufOrString) {\n  if (Buffer.isBuffer(bufOrString)) {\n    bufOrString = bufOrString.toString();\n  }\n  const code = bufOrString.substring(0, 1);\n  bufOrString = bufOrString.substring(1, bufOrString.length);\n  if (typeof bufOrString === 'string') {\n    bufOrString = Buffer.from(bufOrString);\n  }\n  const base = getBase(code);\n  return Buffer.from(base.decode(bufOrString.toString()));\n}\n\n/**\r\n * Is the given data multibase encoded?\r\n *\r\n * @param {Buffer|string} bufOrString\r\n * @returns {boolean}\r\n * @memberof Multibase\r\n */\nfunction isEncoded(bufOrString) {\n  if (Buffer.isBuffer(bufOrString)) {\n    bufOrString = bufOrString.toString();\n  }\n\n  // Ensure bufOrString is a string\n  if (Object.prototype.toString.call(bufOrString) !== '[object String]') {\n    return false;\n  }\n  const code = bufOrString.substring(0, 1);\n  try {\n    const base = getBase(code);\n    return base.name;\n  } catch (err) {\n    return false;\n  }\n}\n\n/**\r\n * @param {string} name\r\n * @param {Buffer} buf\r\n * @private\r\n * @returns {undefined}\r\n */\nfunction validEncode(name, buf) {\n  const base = getBase(name);\n  base.decode(buf.toString());\n}\nfunction getBase(nameOrCode) {\n  let base;\n  if (constants.names[nameOrCode]) {\n    base = constants.names[nameOrCode];\n  } else if (constants.codes[nameOrCode]) {\n    base = constants.codes[nameOrCode];\n  } else {\n    throw new Error('Unsupported encoding');\n  }\n  if (!base.isImplemented()) {\n    throw new Error('Base ' + nameOrCode + ' is not implemented yet');\n  }\n  return base;\n}","map":{"version":3,"names":["Buffer","require","constants","exports","module","multibase","encode","decode","isEncoded","names","Object","freeze","keys","codes","nameOrCode","buf","Error","base","getBase","codeBuf","from","code","name","validEncode","concat","bufOrString","isBuffer","toString","substring","length","prototype","call","err","isImplemented"],"sources":["F:/Farmers_Marketplace1/node_modules/multihashes/node_modules/multibase/src/index.js"],"sourcesContent":["/**\r\n * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.\r\n * @module Multibase\r\n */\r\n'use strict'\r\n\r\nconst { Buffer } = require('buffer')\r\nconst constants = require('./constants')\r\n\r\nexports = module.exports = multibase\r\nexports.encode = encode\r\nexports.decode = decode\r\nexports.isEncoded = isEncoded\r\nexports.names = Object.freeze(Object.keys(constants.names))\r\nexports.codes = Object.freeze(Object.keys(constants.codes))\r\n\r\n/**\r\n * Create a new buffer with the multibase varint+code.\r\n *\r\n * @param {string|number} nameOrCode - The multibase name or code number.\r\n * @param {Buffer} buf - The data to be prefixed with multibase.\r\n * @memberof Multibase\r\n * @returns {Buffer}\r\n */\r\nfunction multibase (nameOrCode, buf) {\r\n  if (!buf) {\r\n    throw new Error('requires an encoded buffer')\r\n  }\r\n  const base = getBase(nameOrCode)\r\n  const codeBuf = Buffer.from(base.code)\r\n\r\n  const name = base.name\r\n  validEncode(name, buf)\r\n  return Buffer.concat([codeBuf, buf])\r\n}\r\n\r\n/**\r\n * Encode data with the specified base and add the multibase prefix.\r\n *\r\n * @param {string|number} nameOrCode - The multibase name or code number.\r\n * @param {Buffer} buf - The data to be encoded.\r\n * @returns {Buffer}\r\n * @memberof Multibase\r\n */\r\nfunction encode (nameOrCode, buf) {\r\n  const base = getBase(nameOrCode)\r\n  const name = base.name\r\n\r\n  return multibase(name, Buffer.from(base.encode(buf)))\r\n}\r\n\r\n/**\r\n * Takes a buffer or string encoded with multibase header, decodes it and\r\n * returns the decoded buffer\r\n *\r\n * @param {Buffer|string} bufOrString\r\n * @returns {Buffer}\r\n * @memberof Multibase\r\n *\r\n */\r\nfunction decode (bufOrString) {\r\n  if (Buffer.isBuffer(bufOrString)) {\r\n    bufOrString = bufOrString.toString()\r\n  }\r\n\r\n  const code = bufOrString.substring(0, 1)\r\n  bufOrString = bufOrString.substring(1, bufOrString.length)\r\n\r\n  if (typeof bufOrString === 'string') {\r\n    bufOrString = Buffer.from(bufOrString)\r\n  }\r\n\r\n  const base = getBase(code)\r\n  return Buffer.from(base.decode(bufOrString.toString()))\r\n}\r\n\r\n/**\r\n * Is the given data multibase encoded?\r\n *\r\n * @param {Buffer|string} bufOrString\r\n * @returns {boolean}\r\n * @memberof Multibase\r\n */\r\nfunction isEncoded (bufOrString) {\r\n  if (Buffer.isBuffer(bufOrString)) {\r\n    bufOrString = bufOrString.toString()\r\n  }\r\n\r\n  // Ensure bufOrString is a string\r\n  if (Object.prototype.toString.call(bufOrString) !== '[object String]') {\r\n    return false\r\n  }\r\n\r\n  const code = bufOrString.substring(0, 1)\r\n  try {\r\n    const base = getBase(code)\r\n    return base.name\r\n  } catch (err) {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string} name\r\n * @param {Buffer} buf\r\n * @private\r\n * @returns {undefined}\r\n */\r\nfunction validEncode (name, buf) {\r\n  const base = getBase(name)\r\n  base.decode(buf.toString())\r\n}\r\n\r\nfunction getBase (nameOrCode) {\r\n  let base\r\n\r\n  if (constants.names[nameOrCode]) {\r\n    base = constants.names[nameOrCode]\r\n  } else if (constants.codes[nameOrCode]) {\r\n    base = constants.codes[nameOrCode]\r\n  } else {\r\n    throw new Error('Unsupported encoding')\r\n  }\r\n\r\n  if (!base.isImplemented()) {\r\n    throw new Error('Base ' + nameOrCode + ' is not implemented yet')\r\n  }\r\n\r\n  return base\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}