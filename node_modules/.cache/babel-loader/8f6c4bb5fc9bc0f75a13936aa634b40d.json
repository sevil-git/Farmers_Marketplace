{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst mh = require('multihashes');\nconst multibase = require('multibase');\nconst multicodec = require('multicodec');\nconst codecs = require('multicodec/src/base-table.json');\nconst CIDUtil = require('./cid-util');\nconst withIs = require('class-is');\n\n/**\r\n * @typedef {Object} SerializedCID\r\n * @param {string} codec\r\n * @param {number} version\r\n * @param {Buffer} multihash\r\n */\n\n/**\r\n * Test if the given input is a CID.\r\n * @function isCID\r\n * @memberof CID\r\n * @static\r\n * @param {any} other\r\n * @returns {bool}\r\n */\n\n/**\r\n * Class representing a CID `<mbase><version><mcodec><mhash>`\r\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\r\n * @class CID\r\n */\nclass CID {\n  /**\r\n   * Create a new CID.\r\n   *\r\n   * The algorithm for argument input is roughly:\r\n   * ```\r\n   * if (cid)\r\n   *   -> create a copy\r\n   * else if (str)\r\n   *   if (1st char is on multibase table) -> CID String\r\n   *   else -> bs58 encoded multihash\r\n   * else if (Buffer)\r\n   *   if (1st byte is 0 or 1) -> CID\r\n   *   else -> multihash\r\n   * else if (Number)\r\n   *   -> construct CID by parts\r\n   * ```\r\n   *\r\n   * @param {string|Buffer|CID} version\r\n   * @param {string} [codec]\r\n   * @param {Buffer} [multihash]\r\n   * @param {string} [multibaseName]\r\n   *\r\n   * @example\r\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\r\n   * new CID(<cidStr>)\r\n   * new CID(<cid.buffer>)\r\n   * new CID(<multihash>)\r\n   * new CID(<bs58 encoded multihash>)\r\n   * new CID(<cid>)\r\n   */\n  constructor(version, codec, multihash, multibaseName) {\n    if (_CID.isCID(version)) {\n      // version is an exising CID instance\n      const cid = version;\n      this.version = cid.version;\n      this.codec = cid.codec;\n      this.multihash = Buffer.from(cid.multihash);\n      // Default guard for when a CID < 0.7 is passed with no multibaseName\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32');\n      return;\n    }\n    if (typeof version === 'string') {\n      // e.g. 'base32' or false\n      const baseName = multibase.isEncoded(version);\n      if (baseName) {\n        // version is a CID String encoded with multibase, so v1\n        const cid = multibase.decode(version);\n        this.version = parseInt(cid.slice(0, 1).toString('hex'), 16);\n        this.codec = multicodec.getCodec(cid.slice(1));\n        this.multihash = multicodec.rmPrefix(cid.slice(1));\n        this.multibaseName = baseName;\n      } else {\n        // version is a base58btc string multihash, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = mh.fromB58String(version);\n        this.multibaseName = 'base58btc';\n      }\n      CID.validateCID(this);\n      Object.defineProperty(this, 'string', {\n        value: version\n      });\n      return;\n    }\n    if (Buffer.isBuffer(version)) {\n      const firstByte = version.slice(0, 1);\n      const v = parseInt(firstByte.toString('hex'), 16);\n      if (v === 1) {\n        // version is a CID buffer\n        const cid = version;\n        this.version = v;\n        this.codec = multicodec.getCodec(cid.slice(1));\n        this.multihash = multicodec.rmPrefix(cid.slice(1));\n        this.multibaseName = 'base32';\n      } else {\n        // version is a raw multihash buffer, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = version;\n        this.multibaseName = 'base58btc';\n      }\n      CID.validateCID(this);\n      return;\n    }\n\n    // otherwise, assemble the CID from the parameters\n\n    /**\r\n     * @type {number}\r\n     */\n    this.version = version;\n\n    /**\r\n     * @type {string}\r\n     */\n    this.codec = codec;\n\n    /**\r\n     * @type {Buffer}\r\n     */\n    this.multihash = multihash;\n\n    /**\r\n     * @type {string}\r\n     */\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32');\n    CID.validateCID(this);\n  }\n\n  /**\r\n   * The CID as a `Buffer`\r\n   *\r\n   * @return {Buffer}\r\n   * @readonly\r\n   *\r\n   * @memberOf CID\r\n   */\n  get buffer() {\n    let buffer = this._buffer;\n    if (!buffer) {\n      if (this.version === 0) {\n        buffer = this.multihash;\n      } else if (this.version === 1) {\n        buffer = Buffer.concat([Buffer.from('01', 'hex'), multicodec.getCodeVarint(this.codec), this.multihash]);\n      } else {\n        throw new Error('unsupported version');\n      }\n\n      // Cache this buffer so it doesn't have to be recreated\n      Object.defineProperty(this, '_buffer', {\n        value: buffer\n      });\n    }\n    return buffer;\n  }\n\n  /**\r\n   * Get the prefix of the CID.\r\n   *\r\n   * @returns {Buffer}\r\n   * @readonly\r\n   */\n  get prefix() {\n    return Buffer.concat([Buffer.from(`0${this.version}`, 'hex'), multicodec.getCodeVarint(this.codec), mh.prefix(this.multihash)]);\n  }\n\n  /**\r\n   * Convert to a CID of version `0`.\r\n   *\r\n   * @returns {CID}\r\n   */\n  toV0() {\n    if (this.codec !== 'dag-pb') {\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n    }\n    const {\n      name,\n      length\n    } = mh.decode(this.multihash);\n    if (name !== 'sha2-256') {\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n    }\n    if (length !== 32) {\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0');\n    }\n    return new _CID(0, this.codec, this.multihash);\n  }\n\n  /**\r\n   * Convert to a CID of version `1`.\r\n   *\r\n   * @returns {CID}\r\n   */\n  toV1() {\n    return new _CID(1, this.codec, this.multihash);\n  }\n\n  /**\r\n   * Encode the CID into a string.\r\n   *\r\n   * @param {string} [base=this.multibaseName] - Base encoding to use.\r\n   * @returns {string}\r\n   */\n  toBaseEncodedString() {\n    let base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.multibaseName;\n    if (this.string && base === this.multibaseName) {\n      return this.string;\n    }\n    let str = null;\n    if (this.version === 0) {\n      if (base !== 'base58btc') {\n        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()');\n      }\n      str = mh.toB58String(this.multihash);\n    } else if (this.version === 1) {\n      str = multibase.encode(base, this.buffer).toString();\n    } else {\n      throw new Error('unsupported version');\n    }\n    if (base === this.multibaseName) {\n      // cache the string value\n      Object.defineProperty(this, 'string', {\n        value: str\n      });\n    }\n    return str;\n  }\n\n  /**\r\n   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\r\n   *\r\n   * @returns {String}\r\n   */\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return 'CID(' + this.toString() + ')';\n  }\n  toString(base) {\n    return this.toBaseEncodedString(base);\n  }\n\n  /**\r\n   * Serialize to a plain object.\r\n   *\r\n   * @returns {SerializedCID}\r\n   */\n  toJSON() {\n    return {\n      codec: this.codec,\n      version: this.version,\n      hash: this.multihash\n    };\n  }\n\n  /**\r\n   * Compare equality with another CID.\r\n   *\r\n   * @param {CID} other\r\n   * @returns {bool}\r\n   */\n  equals(other) {\n    return this.codec === other.codec && this.version === other.version && this.multihash.equals(other.multihash);\n  }\n\n  /**\r\n   * Test if the given input is a valid CID object.\r\n   * Throws if it is not.\r\n   *\r\n   * @param {any} other\r\n   * @returns {void}\r\n   */\n  static validateCID(other) {\n    const errorMsg = CIDUtil.checkCIDComponents(other);\n    if (errorMsg) {\n      throw new Error(errorMsg);\n    }\n  }\n}\nconst _CID = withIs(CID, {\n  className: 'CID',\n  symbolName: '@ipld/js-cid/CID'\n});\n_CID.codecs = codecs;\nmodule.exports = _CID;","map":{"version":3,"names":["Buffer","require","mh","multibase","multicodec","codecs","CIDUtil","withIs","CID","constructor","version","codec","multihash","multibaseName","_CID","isCID","cid","from","baseName","isEncoded","decode","parseInt","slice","toString","getCodec","rmPrefix","fromB58String","validateCID","Object","defineProperty","value","isBuffer","firstByte","v","buffer","_buffer","concat","getCodeVarint","Error","prefix","toV0","name","length","toV1","toBaseEncodedString","base","arguments","undefined","string","str","toB58String","encode","Symbol","for","toJSON","hash","equals","other","errorMsg","checkCIDComponents","className","symbolName","module","exports"],"sources":["F:/Farmers_Marketplace1/node_modules/cids/src/index.js"],"sourcesContent":["'use strict'\r\n\r\nconst { Buffer } = require('buffer')\r\nconst mh = require('multihashes')\r\nconst multibase = require('multibase')\r\nconst multicodec = require('multicodec')\r\nconst codecs = require('multicodec/src/base-table.json')\r\nconst CIDUtil = require('./cid-util')\r\nconst withIs = require('class-is')\r\n\r\n/**\r\n * @typedef {Object} SerializedCID\r\n * @param {string} codec\r\n * @param {number} version\r\n * @param {Buffer} multihash\r\n */\r\n\r\n/**\r\n * Test if the given input is a CID.\r\n * @function isCID\r\n * @memberof CID\r\n * @static\r\n * @param {any} other\r\n * @returns {bool}\r\n */\r\n\r\n/**\r\n * Class representing a CID `<mbase><version><mcodec><mhash>`\r\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\r\n * @class CID\r\n */\r\nclass CID {\r\n  /**\r\n   * Create a new CID.\r\n   *\r\n   * The algorithm for argument input is roughly:\r\n   * ```\r\n   * if (cid)\r\n   *   -> create a copy\r\n   * else if (str)\r\n   *   if (1st char is on multibase table) -> CID String\r\n   *   else -> bs58 encoded multihash\r\n   * else if (Buffer)\r\n   *   if (1st byte is 0 or 1) -> CID\r\n   *   else -> multihash\r\n   * else if (Number)\r\n   *   -> construct CID by parts\r\n   * ```\r\n   *\r\n   * @param {string|Buffer|CID} version\r\n   * @param {string} [codec]\r\n   * @param {Buffer} [multihash]\r\n   * @param {string} [multibaseName]\r\n   *\r\n   * @example\r\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\r\n   * new CID(<cidStr>)\r\n   * new CID(<cid.buffer>)\r\n   * new CID(<multihash>)\r\n   * new CID(<bs58 encoded multihash>)\r\n   * new CID(<cid>)\r\n   */\r\n  constructor (version, codec, multihash, multibaseName) {\r\n    if (_CID.isCID(version)) {\r\n      // version is an exising CID instance\r\n      const cid = version\r\n      this.version = cid.version\r\n      this.codec = cid.codec\r\n      this.multihash = Buffer.from(cid.multihash)\r\n      // Default guard for when a CID < 0.7 is passed with no multibaseName\r\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')\r\n      return\r\n    }\r\n\r\n    if (typeof version === 'string') {\r\n      // e.g. 'base32' or false\r\n      const baseName = multibase.isEncoded(version)\r\n      if (baseName) {\r\n        // version is a CID String encoded with multibase, so v1\r\n        const cid = multibase.decode(version)\r\n        this.version = parseInt(cid.slice(0, 1).toString('hex'), 16)\r\n        this.codec = multicodec.getCodec(cid.slice(1))\r\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\r\n        this.multibaseName = baseName\r\n      } else {\r\n        // version is a base58btc string multihash, so v0\r\n        this.version = 0\r\n        this.codec = 'dag-pb'\r\n        this.multihash = mh.fromB58String(version)\r\n        this.multibaseName = 'base58btc'\r\n      }\r\n      CID.validateCID(this)\r\n      Object.defineProperty(this, 'string', { value: version })\r\n      return\r\n    }\r\n\r\n    if (Buffer.isBuffer(version)) {\r\n      const firstByte = version.slice(0, 1)\r\n      const v = parseInt(firstByte.toString('hex'), 16)\r\n      if (v === 1) {\r\n        // version is a CID buffer\r\n        const cid = version\r\n        this.version = v\r\n        this.codec = multicodec.getCodec(cid.slice(1))\r\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\r\n        this.multibaseName = 'base32'\r\n      } else {\r\n        // version is a raw multihash buffer, so v0\r\n        this.version = 0\r\n        this.codec = 'dag-pb'\r\n        this.multihash = version\r\n        this.multibaseName = 'base58btc'\r\n      }\r\n      CID.validateCID(this)\r\n      return\r\n    }\r\n\r\n    // otherwise, assemble the CID from the parameters\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.version = version\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    this.codec = codec\r\n\r\n    /**\r\n     * @type {Buffer}\r\n     */\r\n    this.multihash = multihash\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')\r\n\r\n    CID.validateCID(this)\r\n  }\r\n\r\n  /**\r\n   * The CID as a `Buffer`\r\n   *\r\n   * @return {Buffer}\r\n   * @readonly\r\n   *\r\n   * @memberOf CID\r\n   */\r\n  get buffer () {\r\n    let buffer = this._buffer\r\n\r\n    if (!buffer) {\r\n      if (this.version === 0) {\r\n        buffer = this.multihash\r\n      } else if (this.version === 1) {\r\n        buffer = Buffer.concat([\r\n          Buffer.from('01', 'hex'),\r\n          multicodec.getCodeVarint(this.codec),\r\n          this.multihash\r\n        ])\r\n      } else {\r\n        throw new Error('unsupported version')\r\n      }\r\n\r\n      // Cache this buffer so it doesn't have to be recreated\r\n      Object.defineProperty(this, '_buffer', { value: buffer })\r\n    }\r\n\r\n    return buffer\r\n  }\r\n\r\n  /**\r\n   * Get the prefix of the CID.\r\n   *\r\n   * @returns {Buffer}\r\n   * @readonly\r\n   */\r\n  get prefix () {\r\n    return Buffer.concat([\r\n      Buffer.from(`0${this.version}`, 'hex'),\r\n      multicodec.getCodeVarint(this.codec),\r\n      mh.prefix(this.multihash)\r\n    ])\r\n  }\r\n\r\n  /**\r\n   * Convert to a CID of version `0`.\r\n   *\r\n   * @returns {CID}\r\n   */\r\n  toV0 () {\r\n    if (this.codec !== 'dag-pb') {\r\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0')\r\n    }\r\n\r\n    const { name, length } = mh.decode(this.multihash)\r\n\r\n    if (name !== 'sha2-256') {\r\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\r\n    }\r\n\r\n    if (length !== 32) {\r\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')\r\n    }\r\n\r\n    return new _CID(0, this.codec, this.multihash)\r\n  }\r\n\r\n  /**\r\n   * Convert to a CID of version `1`.\r\n   *\r\n   * @returns {CID}\r\n   */\r\n  toV1 () {\r\n    return new _CID(1, this.codec, this.multihash)\r\n  }\r\n\r\n  /**\r\n   * Encode the CID into a string.\r\n   *\r\n   * @param {string} [base=this.multibaseName] - Base encoding to use.\r\n   * @returns {string}\r\n   */\r\n  toBaseEncodedString (base = this.multibaseName) {\r\n    if (this.string && base === this.multibaseName) {\r\n      return this.string\r\n    }\r\n    let str = null\r\n    if (this.version === 0) {\r\n      if (base !== 'base58btc') {\r\n        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')\r\n      }\r\n      str = mh.toB58String(this.multihash)\r\n    } else if (this.version === 1) {\r\n      str = multibase.encode(base, this.buffer).toString()\r\n    } else {\r\n      throw new Error('unsupported version')\r\n    }\r\n    if (base === this.multibaseName) {\r\n      // cache the string value\r\n      Object.defineProperty(this, 'string', { value: str })\r\n    }\r\n    return str\r\n  }\r\n\r\n  /**\r\n   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\r\n   *\r\n   * @returns {String}\r\n   */\r\n  [Symbol.for('nodejs.util.inspect.custom')] () {\r\n    return 'CID(' + this.toString() + ')'\r\n  }\r\n\r\n  toString (base) {\r\n    return this.toBaseEncodedString(base)\r\n  }\r\n\r\n  /**\r\n   * Serialize to a plain object.\r\n   *\r\n   * @returns {SerializedCID}\r\n   */\r\n  toJSON () {\r\n    return {\r\n      codec: this.codec,\r\n      version: this.version,\r\n      hash: this.multihash\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compare equality with another CID.\r\n   *\r\n   * @param {CID} other\r\n   * @returns {bool}\r\n   */\r\n  equals (other) {\r\n    return this.codec === other.codec &&\r\n      this.version === other.version &&\r\n      this.multihash.equals(other.multihash)\r\n  }\r\n\r\n  /**\r\n   * Test if the given input is a valid CID object.\r\n   * Throws if it is not.\r\n   *\r\n   * @param {any} other\r\n   * @returns {void}\r\n   */\r\n  static validateCID (other) {\r\n    const errorMsg = CIDUtil.checkCIDComponents(other)\r\n    if (errorMsg) {\r\n      throw new Error(errorMsg)\r\n    }\r\n  }\r\n}\r\n\r\nconst _CID = withIs(CID, {\r\n  className: 'CID',\r\n  symbolName: '@ipld/js-cid/CID'\r\n})\r\n\r\n_CID.codecs = codecs\r\n\r\nmodule.exports = _CID\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}